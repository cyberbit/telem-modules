do local a=package.searchers or package.loaders;local b=a[2]a[2]=function(c)local d={["compress"]=function()local e=require"LibDeflate"local f=require"maketree"local g=require"lz77"local h=require"token_encode_map"local i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"local j={}for k,l in i:gmatch"()(.)"do j[l]=k-1 end;local function m(n)if n%1>=0.5 then return math.ceil(n)else return math.floor(n)end end;local function o(k)if k==0 or k==1 then return{code=k,extra=0,bits=0}end;local p=math.max(select(2,math.frexp(k))-2,0)local q=2^p;return{code=p*2+(bit32.btest(k,q)and 3 or 2),extra=bit32.band(k,q-1),bits=p}end;local function r()return setmetatable({data="",partial=0,len=0},{__call=function(self,s,t)if not s then s,t=0,8-self.len end;if t==0 then return end;assert(s<2^t)self.partial=bit32.bor(bit32.lshift(self.partial,t),s)self.len=self.len+t;while self.len>=8 do local u=bit32.extract(self.partial,self.len-8,8)self.data=self.data..string.char(u)self.len=self.len-8 end end})end;local function v(w,x)local y={}while x>127 do y[#y+1],x=x%128,math.floor(x/128)end;y[#y+1]=x%128;if w then for k=#y,1,-1 do w(y[k]+(k==1 and 0 or 128),8)end end;return#y*8 end;local function z(w,x)if x%1==0 then if w then w(x<0 and 1 or 0,2)end;return v(w,math.abs(x))else local A,B=math.frexp(x)A=m((math.abs(A)-0.5)*0x20000000000000)if A>0xFFFFFFFFFFFFF then B=B+1 end;if w then w((x<0 and 6 or 4)+(B<0 and 1 or 0),3)end;B=math.abs(B)local C={}while B>7 do C[#C+1],B=B%8,math.floor(B/8)end;C[#C+1]=B%8;if w then for k=#C,1,-1 do w(C[k]+(k==1 and 0 or 8),4)end end;return v(w,A)+#C*4+3 end end;local function D(w,E)if not E or next(E)==nil then if w then w(0,5)end;return 5 elseif E.idx then if w then w(0,4)w(1,1)end;return v(w,E.idx-1)+5 end;local F=E.lengths;local G=select(2,math.frexp(E.maxlen))if w then w(G,4)end;local s=4;local l,n=F[1],0;local x,H=1,0;for I,J in ipairs(F)do if J~=l or n==85 then if n>21 then if w then w(3,2)w(n-22,6)end;s=s+8+G elseif n>5 then if w then w(2,2)w(n-6,4)end;s=s+6+G elseif n>1 then if w then w(1,2)w(n-2,2)end;s=s+4+G else if w then w(0,2)end;s=s+2+G end;if w then w(l,G)end;l,n=J,0;x=x+1;if l>1 then H=H+1 end end;n=n+1 end;if n>21 then if w then w(3,2)w(n-22,6)end;s=s+8+G elseif n>5 then if w then w(2,2)w(n-6,4)end;s=s+6+G elseif n>1 then if w then w(1,2)w(n-2,2)end;s=s+4+G else if w then w(0,2)end;s=s+2+G end;if w then w(l,G)end;if l>1 then H=H+1 end;return s end;local function K(L,M)local E={list={}}for k,N in pairs(M)do E.list[k]={N[1],L[N[1]]or 0}end;E.map,E.lengths=f(E.list)if not E.map then if E.map==nil then return nil elseif E.map==false then return{idx=E.lengths,map={[M[E.lengths][1]]={code=0,bits=0,extra=0}}}end end;E.maxlen=0;for I,N in pairs(E.lengths)do E.maxlen=math.max(E.maxlen,N)end;return E end;local function O(P,Q)local R=Q and(Q==0 and 0 or 2^(Q+6))local S,M,T,U={},{},"",{}P=g(P,R)local V={}for I,J in ipairs(P)do if J.type:find"^repeat"then V[J.dist.code]=(V[J.dist.code]or 0)+1 end end;local W={}for k=0,29 do W[k+1]={k,V[k]or 0}end;local X={}X.map,X.lengths=f(W)if X.map then X.maxlen=0;for I,N in ipairs(X.lengths)do X.maxlen=math.max(X.maxlen,N)end elseif X.map==false then X={idx=X.lengths,map={[W[X.lengths][1]]={code=0,bits=0,extra=0}}}end;for k,J in ipairs(P)do if J.type=="name"and not h[J.text]then local Y;for Z,N in ipairs(M)do if N==J.text then Y=Z;break end end;if Y then J.code=o(Y)S[J.code.code]=(S[J.code.code]or 0)+1;table.insert(M,1,table.remove(M,Y))else J.code=o(0)S[0]=(S[0]or 0)+1;U[#U+1]=J.text;table.insert(M,1,J.text)end elseif J.type=="string"and not h[J.text]then J.str=load("return "..J.text,"=string","t",{})()T=T..J.str end end;local _={}for k=0,29 do _[#_+1]={k,S[k]or 0}end;local a0=K(S,_)local L={[":end"]=1}for I,J in ipairs(P)do if h[J.text]then L[J.text]=(L[J.text]or 0)+1 else L[":"..J.type]=(L[":"..J.type]or 0)+1 end end;local a1={}for k=0,29 do if not h[":repeat"..k]then a1[#a1+1]={":repeat"..k,L[":repeat"..k]or 0}end end;for a2 in pairs(h)do a1[#a1+1]={a2,L[a2]or 0}end;table.sort(a1,function(a3,a4)return a3[1]<a4[1]end)local a5=K(L,a1)local a6,a7=D(nil,a5),0;for I,J in ipairs(P)do if h[J.text]then a7=a7+h[J.text].bits;a6=a6+a5.map[J.text].bits elseif J.type=="name"then a7=a7+h[":name"].bits+a0.map[J.code.code].bits+J.code.bits;a6=a6+a5.map[":name"].bits+a0.map[J.code.code].bits+J.code.bits elseif J.type=="string"then a7=a7+h[":string"].bits+v(nil,#J.str)a6=a6+a5.map[":string"].bits+v(nil,#J.str)elseif J.type=="number"then a7=a7+h[":number"].bits+z(nil,tonumber(J.text))a6=a6+a5.map[":number"].bits+z(nil,tonumber(J.text))elseif J.type:find"^repeat"then a7=a7+h[":"..J.type].bits+J.len.bits+X.map[J.dist.code].bits+J.dist.bits;a6=a6+a5.map[":"..J.type].bits+J.len.bits+X.map[J.dist.code].bits+J.dist.bits else error("Could not find encoding for token "..J.type.."("..J.text..")!")end end;print(a7,a6)local w=r()w.data="\27LuzQ"..e:CompressDeflate(T,{level=Q})local a8=#w.data-5;local a9=""for I,J in ipairs(U)do for l in J:gmatch"."do a9=a9 ..string.char(j[l])end;a9=a9 .."\63"end;local aa=e:CompressDeflate(a9,{level=Q})w.data=w.data..aa;local ab=#w.data-a8-5;D(w,X)D(w,a0)local ac;if a6<a7 then w(1,1)D(w,a5)ac=a5.map else w(0,1)ac=h end;print(a8,ab,#w.data-ab-a8-5,#M)local ad,ae,af,ag,ah,ai,aj=0,0,0,0,0,0,0;for I,J in ipairs(P)do if h[J.text]then w(ac[J.text].code,ac[J.text].bits)ad=ad+ac[J.text].bits elseif J.type=="name"then w(ac[":name"].code,ac[":name"].bits)ad=ad+ac[":name"].bits;w(a0.map[J.code.code].code,a0.map[J.code.code].bits)w(J.code.extra,J.code.bits)ae=ae+a0.map[J.code.code].bits+J.code.bits elseif J.type=="string"then w(ac[":string"].code,ac[":string"].bits)ad=ad+ac[":string"].bits;af=af+v(w,#J.str)elseif J.type=="number"then w(ac[":number"].code,ac[":number"].bits)ad=ad+ac[":number"].bits;ag=ag+z(w,tonumber(J.text))elseif J.type:find"^repeat"then w(ac[":"..J.type].code,ac[":"..J.type].bits)ad=ad+ac[":"..J.type].bits;w(J.len.extra,J.len.bits)w(X.map[J.dist.code].code,X.map[J.dist.code].bits)w(J.dist.extra,J.dist.bits)ah=ah+J.len.bits+X.map[J.dist.code].bits+J.dist.bits;aj=aj+1 else error("Could not find encoding for token "..J.type.."("..J.text..")!")end end;w(ac[":end"].code,ac[":end"].bits)w()ad=ad+h[":end"].bits;print(ad/8,ae/8,af/8,ag/8,ah/8,ai/8,aj)return w.data end;return O end,["decompress"]=function()local ak=require'token_decode_tree'local al,am,an=bit32.rshift,bit32.lshift,bit32.band;local u,ao=string.byte,string.char;local ap,unpack=table.concat,unpack or table.unpack;local aq=math.min;local ar={17,18,19,1,9,8,10,7,11,6,12,5,13,4,14,3,15,2,16}local as={2,3,7}local at={144,112,24,8}local au={8,9,7,8}local av={[0]=5,261,133,389,69,325,197,453,37,293,165,421,101,357,229,485,21,277,149,405,85,341,213,469,53,309,181,437,117,373,245,501}local aw=5;local i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"local j={}for k=1,#i do j[string.char(k-1)]=i:sub(k,k)end;local function ax(ay,az)ay.bits=al(ay.bits,az)ay.count=ay.count-az end;local function aA(ay,az)local aB,s,aC,aD=ay.buffer,ay.bits,ay.count,ay.position;while aC<az do if aD>#aB then return nil end;s=s+am(u(aB,aD),aC)aD=aD+1;aC=aC+8 end;ay.bits=s;ay.position=aD;ay.count=aC;return an(s,am(1,az)-1)end;local function aE(ay,az)local aF=aA(ay,az)ay.bits=al(ay.bits,az)ay.count=ay.count-az;return aF end;local function aG(ay,az)local aB,s,aC,aD=ay.buffer,ay.bits,ay.count,ay.position;while aC<az do if aD>#aB then return nil end;s=am(s,8)+u(aB,aD)aD=aD+1;aC=aC+8 end;ay.bits=s;ay.position=aD;ay.count=aC;return an(al(s,aC-az),am(1,az)-1)end;local function aH(ay,az)local aF=aG(ay,az)ay.count=ay.count-az;return aF end;local function aI(ay,aJ,az)local aK=aJ[aA(ay,az)]if not aK then return nil end;local aL=an(aK,15)local aF=al(aK,4)ay.bits=al(ay.bits,aL)ay.count=ay.count-aL;return aF end;local function aM(aN)local aO=#aN;local aP,aQ,aJ={[0]=0},{},{}local s,Y=1,0;for k=1,aO do local aR=aN[k]if aR>s then s=aR end;aP[aR]=(aP[aR]or 0)+1 end;for k=1,s do Y=(Y+(aP[k-1]or 0))*2;aQ[k]=Y end;for k=1,aO do local aR=aN[k]if aR>0 then local aK=(k-1)*16+aR;local aS=0;for Z=1,aR do aS=aS+am(an(1,al(aQ[aR],Z-1)),aR-Z)end;for Z=0,2^s-1,2^aR do aJ[Z+aS]=aK end;aQ[aR]=aQ[aR]+1 end end;return aJ,s end;local function aT(aU,ay,aV,aW,aX,aY)local aZ=#aU+1;local a_;repeat a_=aI(ay,aV,aW)if not a_ then return nil end;if a_<256 then aU[aZ]=a_;aZ=aZ+1 elseif a_>256 then local s,aO,X=0,3,1;if a_<265 then aO=aO+a_-257 elseif a_<285 then s=al(a_-261,2)aO=aO+am(an(a_-261,3)+4,s)else aO=258 end;if s>0 then aO=aO+aE(ay,s)end;local aK=aI(ay,aX,aY)if aK<4 then X=X+aK else s=al(aK-2,1)X=X+am(an(aK,1)+2,s)+aE(ay,s)end;local aD=aZ-X;repeat aU[aZ]=aU[aD]or 0;aZ=aZ+1;aD=aD+1;aO=aO-1 until aO==0 end until a_==256 end;local function b0(aU,ay)local n=aE(ay,5)if not n then return nil end;local a_,X,aL=257+n,1+aE(ay,5),4+aE(ay,4)local aN={}for k=1,aL do aN[ar[k]]=aE(ay,3)end;for k=aL+1,19 do aN[ar[k]]=0 end;local b1,b2=aM(aN)local k=1;local b3=a_+X+1;repeat local aK=aI(ay,b1,b2)if aK<16 then aN[k]=aK;k=k+1 elseif aK<19 then local az=as[aK-15]local aC=0;local x=3+aE(ay,az)if aK==16 then aC=aN[k-1]elseif aK==18 then x=x+8 end;for I=1,x do aN[k]=aC;k=k+1 end end until k==b3;local b4,b5={},{}for Z=1,a_ do b4[Z]=aN[Z]end;for Z=a_+1,#aN do b5[#b5+1]=aN[Z]end;local aV,aW=aM(b4)local aX,aY=aM(b5)aT(aU,ay,aV,aW,aX,aY)end;local function b6(aU,ay)local aN={}for k=1,4 do local aR=au[k]for I=1,at[k]do aN[#aN+1]=aR end end;local aV,aW=aM(aN)aT(aU,ay,aV,aW,av,aw)end;local function b7(aU,ay)ax(ay,an(ay.count,7))local aL=aE(ay,16)aE(ay,16)if not aL then return nil end;local aB,aD=ay.buffer,ay.position;for k=aD,aD+aL-1 do aU[#aU+1]=u(aB,k,k)end;ay.position=aD+aL end;local function v(ay)local x=0;repeat local n=aH(ay,8)x=x*128+n%128 until n<128;return x end;local function z(ay)local type=aH(ay,2)if type>=2 then local b8=aH(ay,1)local B=0;repeat local n=aH(ay,4)B=am(B,3)+an(n,7)until n<8;if b8==1 then B=-B end;local A=v(ay)/0x20000000000000+0.5;return math.ldexp(A,B)*(type==2 and 1 or-1)else return v(ay)*(type==0 and 1 or-1)end end;local b9={2,6,22}local function ba(ay,t)local s=aH(ay,2)if s==0 then return 1,aH(ay,t)end;local bb=aH(ay,s*2)+b9[s]return bb,aH(ay,t)end;local function D(ay,bc)local G=aH(ay,4)if G==0 then if aH(ay,1)==0 then return nil else return v(ay)end end;local bd={}local n,l=0;for k=1,#bc do if n==0 then n,l=ba(ay,G)end;if l>0 then bd[#bd+1]={s=bc[k],l=l}end;n=n-1 end;assert(n==0,n)table.sort(bd,function(a3,a4)if a3.l==a4.l then return a3.s<a4.s else return a3.l<a4.l end end)bd[1].c=0;for Z=2,#bd do bd[Z].c=bit32.lshift(bd[Z-1].c+1,bd[Z].l-bd[Z-1].l)end;local be={}for Z=1,#bd do local l=bd[Z].c;local bf=be;for a2=bd[Z].l-1,1,-1 do local n=bit32.extract(l,a2,1)if not bf[n+1]then bf[n+1]={}end;bf=bf[n+1]end;local n=bit32.extract(l,0,1)bf[n+1]=bd[Z].s end;return be end;local function bg(bh)if bh:sub(1,5)~="\27LuzQ"then error("invalid format",2)end;local self={buffer=bh,position=6,bits=0,count=0}local T,bi;do local aU,aB={},{}local bj,bk;repeat bj,bk=aE(self,1),aE(self,2)if not bj or not bk then break end;bk=bk==0 and b7(aU,self)or bk==1 and b6(aU,self)or bk==2 and b0(aU,self)until bj==1;local aO=#aU;for k=1,aO,4096 do aB[#aB+1]=ao(unpack(aU,k,aq(k+4095,aO)))end;T=ap(aB)if self.count%8>0 then ax(self,self.count%8)end end;do local aU,aB={},{}local bj,bk;repeat bj,bk=aE(self,1),aE(self,2)if not bj or not bk then break end;bk=bk==0 and b7(aU,self)or bk==1 and b6(aU,self)or bk==2 and b0(aU,self)until bj==1;local aO=#aU;for k=1,aO,4096 do aB[#aB+1]=ao(unpack(aU,k,aq(k+4095,aO)))end;bi=ap(aB)if self.count%8>0 then ax(self,self.count%8)end end;local bl={}for bm in bi:gmatch"([%z\1-\62]+)\63"do bl[#bl+1]=bm:gsub(".",j)end;local bn=D(self,{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29})local be=D(self,{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29})local bo;if aH(self,1)==1 then local a1,A={},{}local function bp(bf)if type(bf)=="string"then a1[#a1+1],A[bf]=bf,true else bp(bf[1])bp(bf[2])end end;bp(ak)for k=0,29 do if not A[":repeat"..k]then a1[#a1+1]=":repeat"..k end end;table.sort(a1)bo=D(self,a1)else bo=ak end;local bq,br=1,1;local P={}local M={}while true do local bf=bo;while type(bf)=="table"do bf=bf[aH(self,1)+1]end;if bf==":end"then break elseif bf==":name"then bf=be;while type(bf)=="table"do bf=bf[aH(self,1)+1]end;local p,o=math.max(math.floor(bf/2)-1,0)if p>0 then local bs=aH(self,p)o=bit32.bor(bs,bit32.lshift(bit32.band(bf,1)+2,p))else o=bf end;if o==0 then P[#P+1]=bl[br]table.insert(M,1,bl[br])br=br+1 else local bt=table.remove(M,o)P[#P+1]=bt;table.insert(M,1,bt)end elseif bf==":string"then local t=v(self)P[#P+1]=("%q"):format(T:sub(bq,bq+t-1)):gsub("\\?\n","\\n"):gsub("\t","\\t"):gsub("[%z\1-\31\127-\255]",function(n)return("\\%03d"):format(n:byte())end)bq=bq+t elseif bf==":number"then P[#P+1]=tostring(z(self))elseif bf:find"^:repeat"then local bu=tonumber(bf:match"^:repeat(%d+)")local p=math.max(math.floor(bu/2)-1,0)if p>0 then local bs=aH(self,p)bu=bit32.bor(bs,bit32.lshift(bit32.band(bu,1)+2,p))+3 else bu=bu+3 end;bf=bn;while type(bf)=="table"do bf=bf[aH(self,1)+1]end;local o;p=math.max(math.floor(bf/2)-1,0)if p>0 then local bs=aH(self,p)o=bit32.bor(bs,bit32.lshift(bit32.band(bf,1)+2,p))+1 else o=bf+1 end;for I=1,bu do P[#P+1]=P[#P-o+1]end else P[#P+1]=bf end end;local bv=""local bw,bx=false,false;for I,J in ipairs(P)do if bw and J:match"^[A-Za-z0-9_]"or bx and J:match"^%."then bv=bv.." "end;bv=bv..J;bw,bx=J:match"[A-Za-z0-9_]$",J:match"%.$"end;return bv end;return bg end,["lex"]=function()local by={}function by.__tostring(self)return(self.src or"unknown")..":"..self.line..": "..self.text end;local function bz(bA,bB,bC)error(setmetatable({line=bA,col=bB,text=bC},by),0)end;local bD={operator="^([;:=%.,%[%]%(%)%{%}%+%-%*/%^%%<>~#&|][=%.]?%.?)()",name="^([%a_][%w_]*)()",number="^(%d+%.?%d*)()",scinumber="^(%d+%.?%d*[eE][%+%-]?%d+)()",hexnumber="^(0[xX]%x+%.?%x*)()",scihexnumber="^(0[xX]%x+%.?%x*[pP][%+%-]?%x+)()",linecomment="^(%-%-[^\n]*)()",blockcomment="^(%-%-%[(=*)%[.-%]%2%])()",emptyblockcomment="^(%-%-%[(=*)%[%]%2%])()",blockquote="^(%[(=*)%[.-%]%2%])()",emptyblockquote="^(%[(=*)%[%]%2%])()",dquote='^("[^"]*")()',squote="^('[^']*')()",whitespace="^(%s+)()",invalid="^([^%w%s_;:=%.,%[%]%(%)%{%}%+%-%*/%^%%<>~#&|]+)()"}local bE={"name","scihexnumber","hexnumber","scinumber","number","blockcomment","emptyblockcomment","linecomment","blockquote","emptyblockquote","operator","dquote","squote","whitespace","invalid"}local bF={["break"]=true,["do"]=true,["else"]=true,["elseif"]=true,["end"]=true,["for"]=true,["function"]=true,["if"]=true,["in"]=true,["local"]=true,["repeat"]=true,["return"]=true,["then"]=true,["until"]=true,["while"]=true}local bG={["and"]=true,["not"]=true,["or"]=true,["+"]=true,["-"]=true,["*"]=true,["/"]=true,["%"]=true,["^"]=true,["#"]=true,["=="]=true,["~="]=true,["<="]=true,[">="]=true,["<"]=true,[">"]=true,["="]=true,["("]=true,[")"]=true,["{"]=true,["}"]=true,["["]=true,["]"]=true,["::"]=true,[";"]=true,[":"]=true,[","]=true,["."]=true,[".."]=true}local bH={["&"]=true,["~"]=true,["|"]=true,["<<"]=true,[">>"]=true,["//"]=true}local bI={["true"]=true,["false"]=true,["nil"]=true,["..."]=true}local function bJ(bK,bC)local bL=1;bC=bK.pending..bC;bK.pending=""while true do local bM=false;for k,J in ipairs(bE)do local bN,B,bO=bC:match(bD[J],bL)if bN then if J=="dquote"or J=="squote"then local bP=true;while not bN:gsub("\\.",""):match(bD[J])do local bQ;bQ,B=bC:match(bD[J],B-1)if not bQ then bP=false;break end;bN=bN..bQ:sub(2)end;if not bP then break end elseif J=="operator"and#bN>1 then while not(bG[bN]or bN=="...")and#bN>1 do bN,B=bN:sub(1,-2),B-1 end end;if bO then B=bO end;bM=true;bK[#bK+1]={type=J,text=bN,line=bK.line,col=bK.col}bL=B;local bR=select(2,bN:gsub("\n","\n"))if bR==0 then bK.col=bK.col+#bN else bK.line=bK.line+bR;bK.col=#bN:match("[^\n]*$")end;break end end;if not bM then bK.pending=bC:sub(bL)break end end end;local function bS(bK,bT,bU)for I,J in ipairs(bK)do if J.type=="operator"then if J.text=="..."then J.type="constant"elseif not bG[J.text]and(bT<3 or not bH[J.text])then bz(J.line,J.col,"invalid operator '"..J.text.."'")end elseif J.type=="name"then if bF[J.text]then J.type="keyword"elseif bG[J.text]then J.type="operator"elseif bI[J.text]then J.type="constant"end elseif J.type=="dquote"or J.type=="squote"or J.type=="blockquote"or J.type=="emptyblockquote"then J.type="string"elseif J.type=="linecomment"or J.type=="blockcomment"or J.type=="emptyblockcomment"then J.type="comment"elseif J.type=="hexnumber"or J.type=="scinumber"or J.type=="scihexnumber"then J.type="number"elseif J.type=="invalid"then bz(J.line,J.col,"invalid characters")end end;if bU then local bv={}for I,J in ipairs(bK)do if J.type=="number"and bv[#bv].type=="operator"and bv[#bv].text=="-"then local bV=bv[#bv-1]if bV.type=="operator"and bV.text~="}"and bV.text~="]"and bV.text~=")"or bV.type=="keyword"and bV.text~="end"then J.text="-"..J.text;bv[#bv]=nil end end;if J.type~="whitespace"and(bU~=2 or J.type~="comment")then bv[#bv+1]=J end end;return bv end;bK.pending,bK.line,bK.col=nil;return bK end;local function bW(bX,bT,bU)if type(bX)=="string"then local bh=bX;function bX()local bY=bh;bh=nil;return bY end end;local bK={pending="",line=1,col=1}while true do local bh=bX()if not bh then break end;bJ(bK,bh)end;if bK.pending~=""then bz(bK.line,bK.col,"unfinished string")end;return bS(bK,bT,bU)end;return bW end,["LibDeflate"]=function()local e;do local bZ="1.0.2-release"local b_="LibDeflate"local c0=3;local c1="LibDeflate "..bZ.." Copyright (C) 2018-2021 Haoqian He.".." Licensed under the zlib License"if LibStub then local c2,c3=LibStub:GetLibrary(b_,true)if c2 and c3 and c3>=c0 then return c2 else e=LibStub:NewLibrary(b_,c0)end else e={}end;e._VERSION=bZ;e._MAJOR=b_;e._MINOR=c0;e._COPYRIGHT=c1 end;local assert=assert;local error=error;local pairs=pairs;local c4=string.byte;local c5=string.char;local c6=string.find;local c7=string.gsub;local c8=string.sub;local c9=table.concat;local ca=table.sort;local tostring=tostring;local type=type;local cb={}local cc={}local cd={}local ce={}local cf={}local cg={}local ch={}local ci={}local cj={}local ck={3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258}local cl={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0}local cm={[0]=1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577}local cn={[0]=0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13}local co={16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15}local cp;local cq;local cr;local cs;local ct;local cu;local cv;local cw;for k=0,255 do cc[k]=c5(k)end;do local cx=1;for k=0,32 do cb[k]=cx;cx=cx*2 end end;for k=1,9 do cd[k]={}for Z=0,cb[k+1]-1 do local cy=0;local cz=Z;for I=1,k do cy=cy-cy%2+((cy%2==1 or cz%2==1)and 1 or 0)cz=(cz-cz%2)/2;cy=cy*2 end;cd[k][Z]=(cy-cy%2)/2 end end;do local a3=18;local a4=16;local l=265;local bd=1;for t=3,258 do if t<=10 then ce[t]=t+254;cg[t]=0 elseif t==258 then ce[t]=285;cg[t]=0 else if t>a3 then a3=a3+a4;a4=a4*2;l=l+4;bd=bd+1 end;local cA=t-a3-1+a4/2;ce[t]=(cA-cA%(a4/8))/(a4/8)+l;cg[t]=bd;cf[t]=cA%(a4/8)end end end;do ch[1]=0;ch[2]=1;cj[1]=0;cj[2]=0;local a3=3;local a4=4;local Y=2;local bd=0;for X=3,256 do if X>a4 then a3=a3*2;a4=a4*2;Y=Y+2;bd=bd+1 end;ch[X]=X<=a3 and Y or Y+1;cj[X]=bd<0 and 0 or bd;if a4>=8 then ci[X]=(X-a4/2-1)%(a4/4)end end end;function e:Adler32(cB)if type(cB)~="string"then error(("Usage: LibDeflate:Adler32(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;local cC=#cB;local k=1;local a3=1;local a4=0;while k<=cC-15 do local cD,cE,cF,cG,cH,cI,cJ,cK,cL,cM,cN,cO,cP,cQ,cR,cS=c4(cB,k,k+15)a4=(a4+16*a3+16*cD+15*cE+14*cF+13*cG+12*cH+11*cI+10*cJ+9*cK+8*cL+7*cM+6*cN+5*cO+4*cP+3*cQ+2*cR+cS)%65521;a3=(a3+cD+cE+cF+cG+cH+cI+cJ+cK+cL+cM+cN+cO+cP+cQ+cR+cS)%65521;k=k+16 end;while k<=cC do local cT=c4(cB,k,k)a3=(a3+cT)%65521;a4=(a4+a3)%65521;k=k+1 end;return(a4*65536+a3)%4294967296 end;local function cU(cV,cW)return cV%4294967296==cW%4294967296 end;function e:CreateDictionary(cB,cC,cX)if type(cB)~="string"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;if type(cC)~="number"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'strlen' - number expected got '%s'."):format(type(cC)),2)end;if type(cX)~="number"then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'adler32' - number expected got '%s'."):format(type(cX)),2)end;if cC~=#cB then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'strlen' does not match the actual length of 'str'.".." 'strlen': %u, '#str': %u .".." Please check if 'str' is modified unintentionally."):format(cC,#cB))end;if cC==0 then error("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - Empty string is not allowed.",2)end;if cC>32768 then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'str' - string longer than 32768 bytes is not allowed.".." Got %d bytes."):format(cC),2)end;local cY=self:Adler32(cB)if not cU(cX,cY)then error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):".." 'adler32' does not match the actual adler32 of 'str'.".." 'adler32': %u, 'Adler32(str)': %u .".." Please check if 'str' is modified unintentionally."):format(cX,cY))end;local cZ={}cZ.adler32=cX;cZ.hash_tables={}cZ.string_table={}cZ.strlen=cC;local c_=cZ.string_table;local d0=cZ.hash_tables;c_[1]=c4(cB,1,1)c_[2]=c4(cB,2,2)if cC>=3 then local k=1;local d1=c_[1]*256+c_[2]while k<=cC-2-3 do local cD,cE,cF,cG=c4(cB,k+2,k+5)c_[k+2]=cD;c_[k+3]=cE;c_[k+4]=cF;c_[k+5]=cG;d1=(d1*256+cD)%16777216;local cA=d0[d1]if not cA then cA={}d0[d1]=cA end;cA[#cA+1]=k-cC;k=k+1;d1=(d1*256+cE)%16777216;cA=d0[d1]if not cA then cA={}d0[d1]=cA end;cA[#cA+1]=k-cC;k=k+1;d1=(d1*256+cF)%16777216;cA=d0[d1]if not cA then cA={}d0[d1]=cA end;cA[#cA+1]=k-cC;k=k+1;d1=(d1*256+cG)%16777216;cA=d0[d1]if not cA then cA={}d0[d1]=cA end;cA[#cA+1]=k-cC;k=k+1 end;while k<=cC-2 do local cT=c4(cB,k+2)c_[k+2]=cT;d1=(d1*256+cT)%16777216;local cA=d0[d1]if not cA then cA={}d0[d1]=cA end;cA[#cA+1]=k-cC;k=k+1 end end;return cZ end;local function d2(cZ)if type(cZ)~="table"then return false,("'dictionary' - table expected got '%s'."):format(type(cZ))end;if type(cZ.adler32)~="number"or type(cZ.string_table)~="table"or type(cZ.strlen)~="number"or cZ.strlen<=0 or cZ.strlen>32768 or cZ.strlen~=#cZ.string_table or type(cZ.hash_tables)~="table"then return false,("'dictionary' - corrupted dictionary."):format(type(cZ))end;return true,""end;local d3={[0]={false,nil,0,0,0},[1]={false,nil,4,8,4},[2]={false,nil,5,18,8},[3]={false,nil,6,32,32},[4]={true,4,4,16,16},[5]={true,8,16,32,32},[6]={true,8,16,128,128},[7]={true,8,32,128,256},[8]={true,32,128,258,1024},[9]={true,32,258,258,4096}}local function d4(cB,d5,cZ,d6,d7)if type(cB)~="string"then return false,("'str' - string expected got '%s'."):format(type(cB))end;if d5 then local d8,d9=d2(cZ)if not d8 then return false,d9 end end;if d6 then local da=type(d7)if da~="nil"and da~="table"then return false,("'configs' - nil or table expected got '%s'."):format(type(d7))end;if da=="table"then for a2,J in pairs(d7)do if a2~="level"and a2~="strategy"then return false,("'configs' - unsupported table key in the configs: '%s'."):format(a2)elseif a2=="level"and not d3[J]then return false,("'configs' - unsupported 'level': %s."):format(tostring(J))elseif a2=="strategy"and J~="fixed"and J~="huffman_only"and J~="dynamic"then return false,("'configs' - unsupported 'strategy': '%s'."):format(tostring(J))end end end end;return true,""end;local db=0;local dc=1;local dd=2;local de=3;local function df()local dg=0;local dh=0;local di=0;local dj=0;local aB={}local dk={}local function dl(cz,bd)dh=dh+cz*cb[di]di=di+bd;dj=dj+bd;if di>=32 then dg=dg+1;aB[dg]=cc[dh%256]..cc[(dh-dh%256)/256%256]..cc[(dh-dh%65536)/65536%256]..cc[(dh-dh%16777216)/16777216%256]local dm=cb[32-di+bd]dh=(cz-cz%dm)/dm;di=di-32 end end;local function dn(cB)for I=1,di,8 do dg=dg+1;aB[dg]=c5(dh%256)dh=(dh-dh%256)/256 end;di=0;dg=dg+1;aB[dg]=cB;dj=dj+#cB*8 end;local function dp(dq)if dq==de then return dj end;if dq==dc or dq==dd then local dr=(8-di%8)%8;if di>0 then dh=dh-cb[di]+cb[di+dr]for I=1,di,8 do dg=dg+1;aB[dg]=cc[dh%256]dh=(dh-dh%256)/256 end;dh=0;di=0 end;if dq==dd then dj=dj+dr;return dj end end;local ds=c9(aB)aB={}dg=0;dk[#dk+1]=ds;if dq==db then return dj else return dj,c9(dk)end end;return dl,dn,dp end;local function dt(du,B,dv)dv=dv+1;du[dv]=B;local cz=B[1]local dw=dv;local dx=(dw-dw%2)/2;while dx>=1 and du[dx][1]>cz do local cA=du[dx]du[dx]=B;du[dw]=cA;dw=dx;dx=(dx-dx%2)/2 end end;local function dy(du,dv)local dz=du[1]local B=du[dv]local cz=B[1]du[1]=B;du[dv]=dz;dv=dv-1;local dw=1;local dA=dw*2;local dB=dA+1;while dA<=dv do local dC=du[dA]if dB<=dv and du[dB][1]<dC[1]then local dD=du[dB]if dD[1]<cz then du[dB]=B;du[dw]=dD;dw=dB;dA=dw*2;dB=dA+1 else break end else if dC[1]<cz then du[dA]=B;du[dw]=dC;dw=dA;dA=dw*2;dB=dA+1 else break end end end;return dz end;local function dE(dF,dG,dH,dI)local dJ=0;local dK={}local dL={}for bd=1,dI do dJ=(dJ+(dF[bd-1]or 0))*2;dK[bd]=dJ end;for dM=0,dH do local bd=dG[dM]if bd then dJ=dK[bd]dK[bd]=dJ+1;if bd<=9 then dL[dM]=cd[bd][dJ]else local cy=0;for I=1,bd do cy=cy-cy%2+((cy%2==1 or dJ%2==1)and 1 or 0)dJ=(dJ-dJ%2)/2;cy=cy*2 end;dL[dM]=(cy-cy%2)/2 end end end;return dL end;local function dN(a3,a4)return a3[1]<a4[1]or a3[1]==a4[1]and a3[2]<a4[2]end;local function dO(dP,dI,dH)local dv;local dQ=-1;local dR={}local du={}local dG={}local dS={}local dF={}local dT=0;for dM,aC in pairs(dP)do dT=dT+1;dR[dT]={aC,dM}end;if dT==0 then return{},{},-1 elseif dT==1 then local dM=dR[1][2]dG[dM]=1;dS[dM]=0;return dG,dS,dM else ca(dR,dN)dv=dT;for k=1,dv do du[k]=dR[k]end;while dv>1 do local dU=dy(du,dv)dv=dv-1;local dV=dy(du,dv)dv=dv-1;local dW={dU[1]+dV[1],-1,dU,dV}dt(du,dW,dv)dv=dv+1 end;local dX=0;local dY={du[1],0,0,0}local dZ=1;local aZ=1;du[1][1]=0;while aZ<=dZ do local B=dY[aZ]local bd=B[1]local dM=B[2]local dC=B[3]local dD=B[4]if dC then dZ=dZ+1;dY[dZ]=dC;dC[1]=bd+1 end;if dD then dZ=dZ+1;dY[dZ]=dD;dD[1]=bd+1 end;aZ=aZ+1;if bd>dI then dX=dX+1;bd=dI end;if dM>=0 then dG[dM]=bd;dQ=dM>dQ and dM or dQ;dF[bd]=(dF[bd]or 0)+1 end end;if dX>0 then repeat local bd=dI-1;while(dF[bd]or 0)==0 do bd=bd-1 end;dF[bd]=dF[bd]-1;dF[bd+1]=(dF[bd+1]or 0)+2;dF[dI]=dF[dI]-1;dX=dX-2 until dX<=0;aZ=1;for bd=dI,1,-1 do local n=dF[bd]or 0;while n>0 do local dM=dR[aZ][2]dG[dM]=bd;n=n-1;aZ=aZ+1 end end end;dS=dE(dF,dG,dH,dI)return dG,dS,dQ end end;local function d_(e0,e1,e2,e3)local e4=0;local e5={}local e6={}local e7=0;local e8={}local e9=nil;local aC=0;e3=e3<0 and 0 or e3;local ea=e1+e3+1;for Y=0,ea+1 do local t=Y<=e1 and(e0[Y]or 0)or(Y<=ea and(e2[Y-e1-1]or 0)or nil)if t==e9 then aC=aC+1;if t~=0 and aC==6 then e4=e4+1;e5[e4]=16;e7=e7+1;e8[e7]=3;e6[16]=(e6[16]or 0)+1;aC=0 elseif t==0 and aC==138 then e4=e4+1;e5[e4]=18;e7=e7+1;e8[e7]=127;e6[18]=(e6[18]or 0)+1;aC=0 end else if aC==1 then e4=e4+1;e5[e4]=e9;e6[e9]=(e6[e9]or 0)+1 elseif aC==2 then e4=e4+1;e5[e4]=e9;e4=e4+1;e5[e4]=e9;e6[e9]=(e6[e9]or 0)+2 elseif aC>=3 then e4=e4+1;local eb=e9~=0 and 16 or(aC<=10 and 17 or 18)e5[e4]=eb;e6[eb]=(e6[eb]or 0)+1;e7=e7+1;e8[e7]=aC<=10 and aC-3 or aC-11 end;e9=t;if t and t~=0 then e4=e4+1;e5[e4]=t;e6[t]=(e6[t]or 0)+1;aC=0 else aC=1 end end end;return e5,e8,e6 end;local function ec(cB,cA,bL,ed,ee)local k=bL-ee;while k<=ed-15-ee do cA[k],cA[k+1],cA[k+2],cA[k+3],cA[k+4],cA[k+5],cA[k+6],cA[k+7],cA[k+8],cA[k+9],cA[k+10],cA[k+11],cA[k+12],cA[k+13],cA[k+14],cA[k+15]=c4(cB,k+ee,k+15+ee)k=k+16 end;while k<=ed-ee do cA[k]=c4(cB,k+ee,k+ee)k=k+1 end;return cA end;local function ef(Q,c_,d0,eg,eh,ee,cZ)local ei=d3[Q]local ej,ek,el,em,en=ei[1],ei[2],ei[3],ei[4],ei[5]local eo=not ej and el or 2147483646;local ep=en-en%4/4;local d1;local eq;local er;local es=0;if cZ then eq=cZ.hash_tables;er=cZ.string_table;es=cZ.strlen;assert(eg==1)if eh>=eg and es>=2 then d1=er[es-1]*65536+er[es]*256+c_[1]local cA=d0[d1]if not cA then cA={}d0[d1]=cA end;cA[#cA+1]=-1 end;if eh>=eg+1 and es>=1 then d1=er[es]*65536+c_[1]*256+c_[2]local cA=d0[d1]if not cA then cA={}d0[d1]=cA end;cA[#cA+1]=0 end end;local et=es+3;d1=(c_[eg-ee]or 0)*256+(c_[eg+1-ee]or 0)local eu={}local ev=0;local ew={}local ex={}local ey=0;local ez={}local eA={}local eB=0;local eC={}local eD=0;local eE=false;local eF;local eG;local eH=0;local eI=0;local aZ=eg;local eJ=eh+(ej and 1 or 0)while aZ<=eJ do local eK=aZ-ee;local eL=ee-3;eF=eH;eG=eI;eH=0;d1=(d1*256+(c_[eK+2]or 0))%16777216;local eM;local eN;local eO=d0[d1]local eP;if not eO then eP=0;eO={}d0[d1]=eO;if eq then eN=eq[d1]eM=eN and#eN or 0 else eM=0 end else eP=#eO;eN=eO;eM=eP end;if aZ<=eh then eO[eP+1]=aZ end;if eM>0 and aZ+2<=eh and(not ej or eF<el)then local aR=ej and eF>=ek and ep or en;local eQ=eh-aZ;eQ=eQ>=257 and 257 or eQ;eQ=eQ+eK;local eR=eK+3;while eM>=1 and aR>0 do local e9=eN[eM]if aZ-e9>32768 then break end;if e9<aZ then local eS=eR;if e9>=-257 then local eT=e9-eL;while eS<=eQ and c_[eT]==c_[eS]do eS=eS+1;eT=eT+1 end else local eT=et+e9;while eS<=eQ and er[eT]==c_[eS]do eS=eS+1;eT=eT+1 end end;local Z=eS-eK;if Z>eH then eH=Z;eI=aZ-e9 end;if eH>=em then break end end;eM=eM-1;aR=aR-1;if eM==0 and e9>0 and eq then eN=eq[d1]eM=eN and#eN or 0 end end end;if not ej then eF,eG=eH,eI end;if(not ej or eE)and(eF>3 or eF==3 and eG<4096)and eH<=eF then local Y=ce[eF]local eU=cg[eF]local eV,eW,eX;if eG<=256 then eV=ch[eG]eX=ci[eG]eW=cj[eG]else eV=16;eW=7;local a3=384;local a4=512;while true do if eG<=a3 then eX=(eG-a4/2-1)%(a4/4)break elseif eG<=a4 then eX=(eG-a4/2-1)%(a4/4)eV=eV+1;break else eV=eV+2;eW=eW+1;a3=a3*2;a4=a4*2 end end end;ev=ev+1;eu[ev]=Y;ew[Y]=(ew[Y]or 0)+1;ey=ey+1;ex[ey]=eV;ez[eV]=(ez[eV]or 0)+1;if eU>0 then local eY=cf[eF]eB=eB+1;eA[eB]=eY end;if eW>0 then eD=eD+1;eC[eD]=eX end;for k=aZ+1,aZ+eF-(ej and 2 or 1)do d1=(d1*256+(c_[k-ee+2]or 0))%16777216;if eF<=eo then eO=d0[d1]if not eO then eO={}d0[d1]=eO end;eO[#eO+1]=k end end;aZ=aZ+eF-(ej and 1 or 0)eE=false elseif not ej or eE then local Y=c_[ej and eK-1 or eK]ev=ev+1;eu[ev]=Y;ew[Y]=(ew[Y]or 0)+1;aZ=aZ+1 else eE=true;aZ=aZ+1 end end;ev=ev+1;eu[ev]=256;ew[256]=(ew[256]or 0)+1;return eu,eA,ew,ex,eC,ez end;local function eZ(ew,ez)local e_,f0,e1=dO(ew,15,285)local f1,f2,e3=dO(ez,15,29)local f3,e8,f4=d_(e_,e1,f1,e3)local f5,f6=dO(f4,7,18)local f7=0;for k=1,19 do local dM=co[k]local aL=f5[dM]or 0;if aL~=0 then f7=k end end;f7=f7-4;local f8=e1+1-257;local f9=e3+1-1;if f9<0 then f9=0 end;return f8,f9,f7,f5,f6,f3,e8,e_,f0,f1,f2 end;local function fa(eu,ex,f7,f5,f3,e_,f1)local fb=17;fb=fb+(f7+4)*3;for k=1,#f3 do local Y=f3[k]fb=fb+f5[Y]if Y>=16 then fb=fb+(Y==16 and 2 or(Y==17 and 3 or 7))end end;local fc=0;for k=1,#eu do local Y=eu[k]local fd=e_[Y]fb=fb+fd;if Y>256 then fc=fc+1;if Y>264 and Y<285 then local fe=cl[Y-256]fb=fb+fe end;local eV=ex[fc]local ff=f1[eV]fb=fb+ff;if eV>3 then local eW=(eV-eV%2)/2-1;fb=fb+eW end end end;return fb end;local function fg(dl,fh,eu,eA,ex,eC,f8,f9,f7,f5,f6,f3,e8,e_,f0,f1,f2)dl(fh and 1 or 0,1)dl(2,2)dl(f8,5)dl(f9,5)dl(f7,4)for k=1,f7+4 do local dM=co[k]local aL=f5[dM]or 0;dl(aL,3)end;local fi=1;for k=1,#f3 do local Y=f3[k]dl(f6[Y],f5[Y])if Y>=16 then local fj=e8[fi]dl(fj,Y==16 and 2 or(Y==17 and 3 or 7))fi=fi+1 end end;local fc=0;local fk=0;local fl=0;for k=1,#eu do local fm=eu[k]local dJ=f0[fm]local fd=e_[fm]dl(dJ,fd)if fm>256 then fc=fc+1;if fm>264 and fm<285 then fk=fk+1;local fn=eA[fk]local fe=cl[fm-256]dl(fn,fe)end;local fo=ex[fc]local fp=f2[fo]local ff=f1[fo]dl(fp,ff)if fo>3 then fl=fl+1;local eX=eC[fl]local eW=(fo-fo%2)/2-1;dl(eX,eW)end end end end;local function fq(eu,ex)local fb=3;local fc=0;for k=1,#eu do local Y=eu[k]local fd=cr[Y]fb=fb+fd;if Y>256 then fc=fc+1;if Y>264 and Y<285 then local fe=cl[Y-256]fb=fb+fe end;local eV=ex[fc]fb=fb+5;if eV>3 then local eW=(eV-eV%2)/2-1;fb=fb+eW end end end;return fb end;local function fr(dl,fh,eu,eA,ex,eC)dl(fh and 1 or 0,1)dl(1,2)local fc=0;local fk=0;local fl=0;for k=1,#eu do local fs=eu[k]local dJ=cp[fs]local fd=cr[fs]dl(dJ,fd)if fs>256 then fc=fc+1;if fs>264 and fs<285 then fk=fk+1;local fn=eA[fk]local fe=cl[fs-256]dl(fn,fe)end;local eV=ex[fc]local fp=ct[eV]dl(fp,5)if eV>3 then fl=fl+1;local eX=eC[fl]local eW=(eV-eV%2)/2-1;dl(eX,eW)end end end end;local function ft(eg,eh,dj)assert(eh-eg+1<=65535)local fb=3;dj=dj+3;local dr=(8-dj%8)%8;fb=fb+dr;fb=fb+32;fb=fb+(eh-eg+1)*8;return fb end;local function fu(dl,dn,fh,cB,eg,eh,dj)assert(eh-eg+1<=65535)dl(fh and 1 or 0,1)dl(0,2)dj=dj+3;local dr=(8-dj%8)%8;if dr>0 then dl(cb[dr]-1,dr)end;local aO=eh-eg+1;dl(aO,16)local fv=255-aO%256+(255-(aO-aO%256)/256)*256;dl(fv,16)dn(cB:sub(eg,eh))end;local function fw(d7,dl,dn,dp,cB,cZ)local c_={}local d0={}local fh=nil;local eg;local eh;local fx;local dj=dp(de)local cC=#cB;local ee;local Q;local fy;if d7 then if d7.level then Q=d7.level end;if d7.strategy then fy=d7.strategy end end;if not Q then if cC<2048 then Q=7 elseif cC>65536 then Q=3 else Q=5 end end;while not fh do if not eg then eg=1;eh=64*1024-1;ee=0 else eg=eh+1;eh=eh+32*1024;ee=eg-32*1024-1 end;if eh>=cC then eh=cC;fh=true else fh=false end;local eu,eA,ew,ex,eC,ez;local f8,f9,f7,f5,f6,f3,e8,e_,f0,f1,f2;local fz;local fA;local fB;if Q~=0 then ec(cB,c_,eg,eh+3,ee)if eg==1 and cZ then local er=cZ.string_table;local fC=cZ.strlen;for k=0,-fC+1<-257 and-257 or-fC+1,-1 do c_[k]=er[fC+k]end end;if fy=="huffman_only"then eu={}ec(cB,eu,eg,eh,eg-1)eA={}ew={}eu[eh-eg+2]=256;for k=1,eh-eg+2 do local Y=eu[k]ew[Y]=(ew[Y]or 0)+1 end;ex={}eC={}ez={}else eu,eA,ew,ex,eC,ez=ef(Q,c_,d0,eg,eh,ee,cZ)end;f8,f9,f7,f5,f6,f3,e8,e_,f0,f1,f2=eZ(ew,ez)fz=fa(eu,ex,f7,f5,f3,e_,f1)fA=fq(eu,ex)end;fB=ft(eg,eh,dj)local fD=fB;fD=fA and fA<fD and fA or fD;fD=fz and fz<fD and fz or fD;if Q==0 or fy~="fixed"and fy~="dynamic"and fB==fD then fu(dl,dn,fh,cB,eg,eh,dj)dj=dj+fB elseif fy~="dynamic"and(fy=="fixed"or fA==fD)then fr(dl,fh,eu,eA,ex,eC)dj=dj+fA elseif fy=="dynamic"or fz==fD then fg(dl,fh,eu,eA,ex,eC,f8,f9,f7,f5,f6,f3,e8,e_,f0,f1,f2)dj=dj+fz end;if fh then fx=dp(de)else fx=dp(db)end;assert(fx==dj)if not fh then local Z;if cZ and eg==1 then Z=0;while c_[Z]do c_[Z]=nil;Z=Z-1 end end;cZ=nil;Z=1;for k=eh-32767,eh do c_[Z]=c_[k-ee]Z=Z+1 end;for a2,cA in pairs(d0)do local fE=#cA;if fE>0 and eh+1-cA[1]>32768 then if fE==1 then d0[a2]=nil else local fF={}local fG=0;for k=2,fE do Z=cA[k]if eh+1-Z<=32768 then fG=fG+1;fF[fG]=Z end end;d0[a2]=fF end end end end end end;local function fH(cB,cZ,d7)local dl,dn,dp=df()fw(d7,dl,dn,dp,cB,cZ)local dj,aF=dp(dc)local dr=(8-dj%8)%8;return aF,dr end;local function fI(cB,cZ,d7)local dl,dn,dp=df()local fJ=8;local fK=7;local fL=fK*16+fJ;dl(fL,8)local fM=cZ and 1 or 0;local fN=2;local fO=fN*64+fM*32;local fP=31-(fL*256+fO)%31;fO=fO+fP;dl(fO,8)if fM==1 then local cX=cZ.adler32;local fQ=cX%256;cX=(cX-fQ)/256;local fR=cX%256;cX=(cX-fR)/256;local fS=cX%256;cX=(cX-fS)/256;local fT=cX%256;dl(fT,8)dl(fS,8)dl(fR,8)dl(fQ,8)end;fw(d7,dl,dn,dp,cB,cZ)dp(dd)local cX=e:Adler32(cB)local fT=cX%256;cX=(cX-fT)/256;local fS=cX%256;cX=(cX-fS)/256;local fR=cX%256;cX=(cX-fR)/256;local fQ=cX%256;dl(fQ,8)dl(fR,8)dl(fS,8)dl(fT,8)local dj,aF=dp(dc)local dr=(8-dj%8)%8;return aF,dr end;function e:CompressDeflate(cB,d7)local fU,fV=d4(cB,false,nil,true,d7)if not fU then error("Usage: LibDeflate:CompressDeflate(str, configs): "..fV,2)end;return fH(cB,nil,d7)end;function e:CompressDeflateWithDict(cB,cZ,d7)local fU,fV=d4(cB,true,cZ,true,d7)if not fU then error("Usage: LibDeflate:CompressDeflateWithDict".."(str, dictionary, configs): "..fV,2)end;return fH(cB,cZ,d7)end;function e:CompressZlib(cB,d7)local fU,fV=d4(cB,false,nil,true,d7)if not fU then error("Usage: LibDeflate:CompressZlib(str, configs): "..fV,2)end;return fI(cB,nil,d7)end;function e:CompressZlibWithDict(cB,cZ,d7)local fU,fV=d4(cB,true,cZ,true,d7)if not fU then error("Usage: LibDeflate:CompressZlibWithDict".."(str, dictionary, configs): "..fV,2)end;return fI(cB,cZ,d7)end;local function fW(fX)local fY=fX;local fZ=#fX;local f_=1;local di=0;local dh=0;local function g0(bd)local dm=cb[bd]local Y;if bd<=di then Y=dh%dm;dh=(dh-Y)/dm;di=di-bd else local g1=cb[di]local fR,fS,fT,g2=c4(fY,f_,f_+3)dh=dh+((fR or 0)+(fS or 0)*256+(fT or 0)*65536+(g2 or 0)*16777216)*g1;f_=f_+4;di=di+32-bd;Y=dh%dm;dh=(dh-Y)/dm end;return Y end;local function g3(g4,aB,dg)assert(di%8==0)local g5=di/8<g4 and di/8 or g4;for I=1,g5 do local u=dh%256;dg=dg+1;aB[dg]=c5(u)dh=(dh-u)/256 end;di=di-g5*8;g4=g4-g5;if(fZ-f_-g4+1)*8+di<0 then return-1 end;for k=f_,f_+g4-1 do dg=dg+1;aB[dg]=c8(fY,k,k)end;f_=f_+g4;return dg end;local function g6(g7,g8,fD)local Y=0;local g9=0;local aZ=0;local aC;if fD>0 then if di<15 and fY then local g1=cb[di]local fR,fS,fT,g2=c4(fY,f_,f_+3)dh=dh+((fR or 0)+(fS or 0)*256+(fT or 0)*65536+(g2 or 0)*16777216)*g1;f_=f_+4;di=di+32 end;local dm=cb[fD]di=di-fD;Y=dh%dm;dh=(dh-Y)/dm;Y=cd[fD][Y]aC=g7[fD]if Y<aC then return g8[Y]end;aZ=aC;g9=aC*2;Y=Y*2 end;for bd=fD+1,15 do local ga;ga=dh%2;dh=(dh-ga)/2;di=di-1;Y=ga==1 and Y+1-Y%2 or Y;aC=g7[bd]or 0;local gb=Y-g9;if gb<aC then return g8[aZ+gb]end;aZ=aZ+aC;g9=g9+aC;g9=g9*2;Y=Y*2 end;return-10 end;local function gc()return(fZ-f_+1)*8+di end;local function gd()local ge=di%8;local dm=cb[ge]di=di-ge;dh=(dh-dh%dm)/dm end;return g0,g3,g6,gc,gd end;local function gf(cB,cZ)local g0,g3,g6,gc,gd=fW(cB)local bK={ReadBits=g0,ReadBytes=g3,Decode=g6,ReaderBitlenLeft=gc,SkipToByteBoundary=gd,buffer_size=0,buffer={},result_buffer={},dictionary=cZ}return bK end;local function gg(gh,dH,dI)local g7={}local fD=dI;for dM=0,dH do local bd=gh[dM]or 0;fD=bd>0 and bd<fD and bd or fD;g7[bd]=(g7[bd]or 0)+1 end;if g7[0]==dH+1 then return 0,g7,{},0 end;local gi=1;for t=1,dI do gi=gi*2;gi=gi-(g7[t]or 0)if gi<0 then return gi end end;local gj={}gj[1]=0;for t=1,dI-1 do gj[t+1]=gj[t]+(g7[t]or 0)end;local g8={}for dM=0,dH do local bd=gh[dM]or 0;if bd~=0 then local ee=gj[bd]g8[ee]=dM;gj[bd]=gj[bd]+1 end end;return gi,g7,g8,fD end;local function gk(bK,e_,gl,gm,f1,gn,go)local aB,dg,g0,g6,gc,dk=bK.buffer,bK.buffer_size,bK.ReadBits,bK.Decode,bK.ReaderBitlenLeft,bK.result_buffer;local cZ=bK.dictionary;local er;local fC;local gp=1;if cZ and not aB[0]then er=cZ.string_table;fC=cZ.strlen;gp=-fC+1;for k=0,-fC+1<-257 and-257 or-fC+1,-1 do aB[k]=cc[er[fC+k]]end end;repeat local dM=g6(e_,gl,gm)if dM<0 or dM>285 then return-10 elseif dM<256 then dg=dg+1;aB[dg]=cc[dM]elseif dM>256 then dM=dM-256;local bd=ck[dM]bd=dM>=8 and bd+g0(cl[dM])or bd;dM=g6(f1,gn,go)if dM<0 or dM>29 then return-10 end;local X=cm[dM]X=X>4 and X+g0(cn[dM])or X;local gq=dg-X+1;if gq<gp then return-11 end;if gq>=-257 then for I=1,bd do dg=dg+1;aB[dg]=aB[gq]gq=gq+1 end else gq=fC+gq;for I=1,bd do dg=dg+1;aB[dg]=cc[er[gq]]gq=gq+1 end end end;if gc()<0 then return 2 end;if dg>=65536 then dk[#dk+1]=c9(aB,"",1,32768)for k=32769,dg do aB[k-32768]=aB[k]end;dg=dg-32768;aB[dg+1]=nil end until dM==256;bK.buffer_size=dg;return 0 end;local function gr(bK)local aB,dg,g0,g3,gc,gd,dk=bK.buffer,bK.buffer_size,bK.ReadBits,bK.ReadBytes,bK.ReaderBitlenLeft,bK.SkipToByteBoundary,bK.result_buffer;gd()local g4=g0(16)if gc()<0 then return 2 end;local gs=g0(16)if gc()<0 then return 2 end;if g4%256+gs%256~=255 then return-2 end;if(g4-g4%256)/256+(gs-gs%256)/256~=255 then return-2 end;dg=g3(g4,aB,dg)if dg<0 then return 2 end;if dg>=65536 then dk[#dk+1]=c9(aB,"",1,32768)for k=32769,dg do aB[k-32768]=aB[k]end;dg=dg-32768;aB[dg+1]=nil end;bK.buffer_size=dg;return 0 end;local function gt(bK)return gk(bK,cs,cq,7,cw,cu,5)end;local function gu(bK)local g0,g6=bK.ReadBits,bK.Decode;local gv=g0(5)+257;local gw=g0(5)+1;local gx=g0(4)+4;if gv>286 or gw>30 then return-3 end;local f5={}for k=1,gx do f5[co[k]]=g0(3)end;local gy,gz,gA,gB=gg(f5,18,7)if gy~=0 then return-4 end;local e_={}local f1={}local aZ=0;while aZ<gv+gw do local dM;local bd;dM=g6(gz,gA,gB)if dM<0 then return dM elseif dM<16 then if aZ<gv then e_[aZ]=dM else f1[aZ-gv]=dM end;aZ=aZ+1 else bd=0;if dM==16 then if aZ==0 then return-5 end;if aZ-1<gv then bd=e_[aZ-1]else bd=f1[aZ-gv-1]end;dM=3+g0(2)elseif dM==17 then dM=3+g0(3)else dM=11+g0(7)end;if aZ+dM>gv+gw then return-6 end;while dM>0 do dM=dM-1;if aZ<gv then e_[aZ]=bd else f1[aZ-gv]=bd end;aZ=aZ+1 end end end;if(e_[256]or 0)==0 then return-9 end;local gC,gD,gl,gm=gg(e_,gv-1,15)if gC~=0 and(gC<0 or gv~=(gD[0]or 0)+(gD[1]or 0))then return-7 end;local gE,gF,gn,go=gg(f1,gw-1,15)if gE~=0 and(gE<0 or gw~=(gF[0]or 0)+(gF[1]or 0))then return-8 end;return gk(bK,gD,gl,gm,gF,gn,go)end;local function gG(bK)local g0=bK.ReadBits;local fh;while not fh do fh=g0(1)==1;local gH=g0(2)local gI;if gH==0 then gI=gr(bK)elseif gH==1 then gI=gt(bK)elseif gH==2 then gI=gu(bK)else return nil,-1 end;if gI~=0 then return nil,gI end end;bK.result_buffer[#bK.result_buffer+1]=c9(bK.buffer,"",1,bK.buffer_size)local aF=c9(bK.result_buffer)return aF end;local function gJ(cB,cZ)local bK=gf(cB,cZ)local aF,gI=gG(bK)if not aF then return nil,gI end;local gK=bK.ReaderBitlenLeft()local gL=(gK-gK%8)/8;return aF,gL end;local function gM(cB,cZ)local bK=gf(cB,cZ)local g0=bK.ReadBits;local fL=g0(8)if bK.ReaderBitlenLeft()<0 then return nil,2 end;local fJ=fL%16;local fK=(fL-fJ)/16;if fJ~=8 then return nil,-12 end;if fK>7 then return nil,-13 end;local fO=g0(8)if bK.ReaderBitlenLeft()<0 then return nil,2 end;if(fL*256+fO)%31~=0 then return nil,-14 end;local fM=(fO-fO%32)/32%2;local fN=(fO-fO%64)/64%4;if fM==1 then if not cZ then return nil,-16 end;local fT=g0(8)local fS=g0(8)local fR=g0(8)local fQ=g0(8)local cY=fT*16777216+fS*65536+fR*256+fQ;if bK.ReaderBitlenLeft()<0 then return nil,2 end;if not cU(cY,cZ.adler32)then return nil,-17 end end;local aF,gI=gG(bK)if not aF then return nil,gI end;bK.SkipToByteBoundary()local gN=g0(8)local gO=g0(8)local gP=g0(8)local gQ=g0(8)if bK.ReaderBitlenLeft()<0 then return nil,2 end;local gR=gN*16777216+gO*65536+gP*256+gQ;local gS=e:Adler32(aF)if not cU(gR,gS)then return nil,-15 end;local gK=bK.ReaderBitlenLeft()local gL=(gK-gK%8)/8;return aF,gL end;function e:DecompressDeflate(cB)local fU,fV=d4(cB)if not fU then error("Usage: LibDeflate:DecompressDeflate(str): "..fV,2)end;return gJ(cB)end;function e:DecompressDeflateWithDict(cB,cZ)local fU,fV=d4(cB,true,cZ)if not fU then error("Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): "..fV,2)end;return gJ(cB,cZ)end;function e:DecompressZlib(cB)local fU,fV=d4(cB)if not fU then error("Usage: LibDeflate:DecompressZlib(str): "..fV,2)end;return gM(cB)end;function e:DecompressZlibWithDict(cB,cZ)local fU,fV=d4(cB,true,cZ)if not fU then error("Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): "..fV,2)end;return gM(cB,cZ)end;do cr={}for gT=0,143 do cr[gT]=8 end;for gT=144,255 do cr[gT]=9 end;for gT=256,279 do cr[gT]=7 end;for gT=280,287 do cr[gT]=8 end;cv={}for X=0,31 do cv[X]=5 end;local gI;gI,cs,cq=gg(cr,287,9)assert(gI==0)gI,cw,cu=gg(cv,31,5)assert(gI==0)cp=dE(cs,cr,287,9)ct=dE(cw,cv,31,5)end;local gU={["\000"]="%z",["("]="%(",[")"]="%)",["."]="%.",["%"]="%%",["+"]="%+",["-"]="%-",["*"]="%*",["?"]="%?",["["]="%[",["]"]="%]",["^"]="%^",["$"]="%$"}local function gV(cB)return cB:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])",gU)end;function e:CreateCodec(gW,gX,gY)if type(gW)~="string"or type(gX)~="string"or type(gY)~="string"then error("Usage: LibDeflate:CreateCodec(reserved_chars,".." escape_chars, map_chars):".." All arguments must be string.",2)end;if gX==""then return nil,"No escape characters supplied."end;if#gW<#gY then return nil,"The number of reserved characters must be".." at least as many as the number of mapped chars."end;if gW==""then return nil,"No characters to encode."end;local gZ=gW..gX..gY;local g_={}for k=1,#gZ do local u=c4(gZ,k,k)if g_[u]then return nil,"There must be no duplicate characters in the".." concatenation of reserved_chars, escape_chars and".." map_chars."end;g_[u]=true end;local h0={}local h1={}local h2={}local h3={}if#gY>0 then local h4={}local h5={}for k=1,#gY do local h6=c8(gW,k,k)local h7=c8(gY,k,k)h3[h6]=h7;h2[#h2+1]=h6;h5[h7]=h6;h4[#h4+1]=h7 end;h0[#h0+1]="(["..gV(c9(h4)).."])"h1[#h1+1]=h5 end;local h8=1;local h9=c8(gX,h8,h8)local ha=0;local h4={}local h5={}for k=1,#gZ do local l=c8(gZ,k,k)if not h3[l]then while ha>=256 or g_[ha]do ha=ha+1;if ha>255 then h0[#h0+1]=gV(h9).."(["..gV(c9(h4)).."])"h1[#h1+1]=h5;h8=h8+1;h9=c8(gX,h8,h8)ha=0;h4={}h5={}if not h9 or h9==""then return nil,"Out of escape characters."end end end;local hb=cc[ha]h3[l]=h9 ..hb;h2[#h2+1]=l;h5[hb]=l;h4[#h4+1]=hb;ha=ha+1 end;if k==#gZ then h0[#h0+1]=gV(h9).."(["..gV(c9(h4)).."])"h1[#h1+1]=h5 end end;local hc={}local hd="(["..gV(c9(h2)).."])"local he=h3;function hc:Encode(cB)if type(cB)~="string"then error(("Usage: codec:Encode(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;return c7(cB,hd,he)end;local hf=#h0;local hg="(["..gV(gW).."])"function hc:Decode(cB)if type(cB)~="string"then error(("Usage: codec:Decode(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;if c6(cB,hg)then return nil end;for k=1,hf do cB=c7(cB,h0[k],h1[k])end;return cB end;return hc end;local hh;local function hi()return e:CreateCodec("\000","\001","")end;function e:EncodeForWoWAddonChannel(cB)if type(cB)~="string"then error(("Usage: LibDeflate:EncodeForWoWAddonChannel(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;if not hh then hh=hi()end;return hh:Encode(cB)end;function e:DecodeForWoWAddonChannel(cB)if type(cB)~="string"then error(("Usage: LibDeflate:DecodeForWoWAddonChannel(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;if not hh then hh=hi()end;return hh:Decode(cB)end;local function hj()local ha={}for k=128,255 do ha[#ha+1]=cc[k]end;local gW="sS\000\010\013\124%"..c9(ha)return e:CreateCodec(gW,"\029\031","\015\020")end;local hk;function e:EncodeForWoWChatChannel(cB)if type(cB)~="string"then error(("Usage: LibDeflate:EncodeForWoWChatChannel(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;if not hk then hk=hj()end;return hk:Encode(cB)end;function e:DecodeForWoWChatChannel(cB)if type(cB)~="string"then error(("Usage: LibDeflate:DecodeForWoWChatChannel(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;if not hk then hk=hj()end;return hk:Decode(cB)end;local hl={[0]="a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","0","1","2","3","4","5","6","7","8","9","(",")"}local hm={[97]=0,[98]=1,[99]=2,[100]=3,[101]=4,[102]=5,[103]=6,[104]=7,[105]=8,[106]=9,[107]=10,[108]=11,[109]=12,[110]=13,[111]=14,[112]=15,[113]=16,[114]=17,[115]=18,[116]=19,[117]=20,[118]=21,[119]=22,[120]=23,[121]=24,[122]=25,[65]=26,[66]=27,[67]=28,[68]=29,[69]=30,[70]=31,[71]=32,[72]=33,[73]=34,[74]=35,[75]=36,[76]=37,[77]=38,[78]=39,[79]=40,[80]=41,[81]=42,[82]=43,[83]=44,[84]=45,[85]=46,[86]=47,[87]=48,[88]=49,[89]=50,[90]=51,[48]=52,[49]=53,[50]=54,[51]=55,[52]=56,[53]=57,[54]=58,[55]=59,[56]=60,[57]=61,[40]=62,[41]=63}function e:EncodeForPrint(cB)if type(cB)~="string"then error(("Usage: LibDeflate:EncodeForPrint(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;local cC=#cB;local hn=cC-2;local k=1;local aB={}local dg=0;while k<=hn do local cD,cE,cF=c4(cB,k,k+2)k=k+3;local dh=cD+cE*256+cF*65536;local ho=dh%64;dh=(dh-ho)/64;local hp=dh%64;dh=(dh-hp)/64;local hq=dh%64;local hr=(dh-hq)/64;dg=dg+1;aB[dg]=hl[ho]..hl[hp]..hl[hq]..hl[hr]end;local dh=0;local di=0;while k<=cC do local cT=c4(cB,k,k)dh=dh+cT*cb[di]di=di+8;k=k+1 end;while di>0 do local hs=dh%64;dg=dg+1;aB[dg]=hl[hs]dh=(dh-hs)/64;di=di-6 end;return c9(aB)end;function e:DecodeForPrint(cB)if type(cB)~="string"then error(("Usage: LibDeflate:DecodeForPrint(str):".." 'str' - string expected got '%s'."):format(type(cB)),2)end;cB=cB:gsub("^[%c ]+","")cB=cB:gsub("[%c ]+$","")local cC=#cB;if cC==1 then return nil end;local ht=cC-3;local k=1;local aB={}local dg=0;while k<=ht do local cD,cE,cF,cG=c4(cB,k,k+3)cD=hm[cD]cE=hm[cE]cF=hm[cF]cG=hm[cG]if not(cD and cE and cF and cG)then return nil end;k=k+4;local dh=cD+cE*64+cF*4096+cG*262144;local ho=dh%256;dh=(dh-ho)/256;local hp=dh%256;local hq=(dh-hp)/256;dg=dg+1;aB[dg]=cc[ho]..cc[hp]..cc[hq]end;local dh=0;local di=0;while k<=cC do local cT=c4(cB,k,k)cT=hm[cT]if not cT then return nil end;dh=dh+cT*cb[di]di=di+6;k=k+1 end;while di>=8 do local u=dh%256;dg=dg+1;aB[dg]=cc[u]dh=(dh-u)/256;di=di-8 end;return c9(aB)end;local function hu()hk=nil;hh=nil end;e.internals={LoadStringToTable=ec,IsValidDictionary=d2,IsEqualAdler32=cU,_byte_to_6bit_char=hl,_6bit_to_byte=hm,InternalClearCache=hu}return e end,["lz77"]=function()local function o(k)if k==0 or k==1 then return{code=k,extra=0,bits=0}end;local p=math.max(select(2,math.frexp(k))-2,0)local q=2^p;return{code=p*2+(bit32.btest(k,q)and 3 or 2),extra=bit32.band(k,q-1),bits=p}end;local function g(P,R)R=math.min(R or 1024,32768)local bv={}local hv={}local k=1;while k<=#P do local J=P[k]if not J.names and hv[J.type]and hv[J.type][J.text]then local hw=hv[J.type][J.text]local hx,dw=0;for n=#hw,1,-1 do local hy=hw[n]if k-hy>R then break end;for Z=1,math.min(#P-k,129)do local hz=(Z-1)%(k-hy)+1;if P[k+Z].type==P[hy+hz].type and P[k+Z].text==P[hy+hz].text then if Z>hx then hx,dw=Z,hy end;if P[hy+hz].names then break end else break end end end;if hx>=2 then local t=o(hx-2)local X=o(k-dw-1)bv[#bv+1]={type="repeat"..t.code,text="",dist=X,len=t}for Z=0,hx do J=P[k+Z]hv[J.type][J.text][#hv[J.type][J.text]+1]=k+Z end;if P[k+hx].names then bv[#bv].names=P[k+hx].names end;k=k+hx+1;J=nil end end;if J then bv[#bv+1]=J;hv[J.type]=hv[J.type]or{}hv[J.type][J.text]=hv[J.type][J.text]or{}hv[J.type][J.text][#hv[J.type][J.text]+1]=k;k=k+1 end end;return bv end;return g end,["maketree"]=function()local function hA(a3,a4)return a3.weight>a4.weight end;local function hB(a3,a4)if a3.bits==a4.bits then return a3.symbol<a4.symbol else return a3.bits<a4.bits end end;local function hC(bf,aQ,hD,hE)if bf.data then hE.symbol=bf.data;hD[bf.data]=hE;aQ[#aQ+1]=hE else hC(bf[1],aQ,hD,{bits=hE.bits+1,code=hE.code*2})hC(bf[2],aQ,hD,{bits=hE.bits+1,code=hE.code*2+1})end end;local function f(hF)local hG={}for k,J in ipairs(hF)do if J[2]>0 then hG[#hG+1]={data=J[1],weight=J[2]}end end;if#hG==0 then return nil elseif#hG==1 then for k,J in ipairs(hF)do if J[1]==hG[1].data then return false,k end end;return nil end;table.sort(hG,hA)while#hG>1 do local a3,a4=hG[#hG-1],hG[#hG]local n={weight=a3.weight+a4.weight,a3,a4}hG[#hG]=nil;hG[#hG]=n;table.sort(hG,hA)end;local aQ,hD={},{}hC(hG[1],aQ,hD,{bits=0,code=0})table.sort(aQ,hB)aQ[1].code=0;for k=2,#aQ do aQ[k].code=bit32.lshift(aQ[k-1].code+1,aQ[k].bits-aQ[k-1].bits)end;local F={}for k,J in ipairs(hF)do F[k]=hD[J[1]]and hD[J[1]].bits or 0 end;local hH={}for I,J in ipairs(aQ)do if J.bits==1 then hH[J.code+1]=J.symbol else local bf=hH;for n=J.bits-1,1,-1 do local hI=bit32.extract(J.code,n)+1;bf[hI]=bf[hI]or{}bf=bf[hI]end;local hI=bit32.extract(J.code,0)+1;bf[hI]=J.symbol end;J.symbol=nil end;return hD,F,hH end;return f end,["minify"]=function()local hJ="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"local function hK(n)local bN=""while n>=52 do bN,n=bN..hJ:sub(n%52+1,n%52+1),math.floor(n/52)end;return hJ:sub(n%52+1,n%52+1)..bN:reverse()end;local function hL(P,hM,bL,bv)error("Not implemented yet")return bv,bL end;local function hN(P,hM,bL,hO)bL=bL or 1;hO=hO or 0;local hP=setmetatable({},{__index=hM or{}})local bK=1;local bv={}while bL<=#P do local J=P[bL]if bK==1 then if J.type=="keyword"then bv[bL]=J;if J.text=="do"or J.text=="then"then local cA,bN=hN(P,hP,bL+1,hO)for k=bL+1,bN do bv[k]=cA[k]end;bL=bN elseif J.text=="until"then return hL(P,hP,bL+1,bv)elseif J.text=="function"then local hQ=hO;if P[bL+1].type=="name"then bL=bL+1;if hP[P[bL].text]then bv[bL]={col=J.col,line=J.line,type="name",text=hP[P[bL].text]}else bv[bL]=P[bL]end end;bL=bL+1;bv[bL]=P[bL]bL=bL+1;J=P[bL]local hR=setmetatable({},{__index=hP})while J.type~="operator"or J.text~=")"do if J.type=="name"then hR[J.text]=hK(hO)hO=hO+1;bv[bL]={col=J.col,line=J.line,type="name",text=hR[J.text]}else bv[bL]=J end;bL=bL+1;J=P[bL]end;bv[bL]=J;local cA,bN=hN(P,hR,bL+1,hO)for k=bL+1,bN do bv[k]=cA[k]end;bL=bN;hO=hQ elseif J.text=="local"or J.text=="for"then bK=3 elseif J.text=="end"then return bv,bL end elseif J.type=="name"then if hP[J.text]then bv[bL]={col=J.col,line=J.line,type="name",text=hP[J.text]}else bv[bL]=J end elseif J.type=="operator"then bv[bL]=J;if J.text=="."or J.text==":"then bK=2 end else bv[bL]=J end elseif bK==2 then bv[bL]=J;if not(J.type=="operator"and(J.text=="."or J.text==":")or J.type=="name")then bK=1 end elseif bK==3 then if J.type=="keyword"and J.text=="function"then J=bv[bL+1]hP[J.text]=hK(hO)hO=hO+1;bv[bL]={col=J.col,line=J.line,type="name",text=hP[J.text]}local hQ=hO;bL=bL+2;bv[bL]=P[bL]bL=bL+1;J=P[bL]local hR=setmetatable({},{__index=hP})while J.type~="operator"or J.text~=")"do if J.type=="name"then hR[J.text]=hK(hO)hO=hO+1;bv[bL]={col=J.col,line=J.line,type="name",text=hR[J.text]}else bv[bL]=J end;bL=bL+1;J=P[bL]end;bv[bL]=J;local cA,bN=hN(P,hR,bL+1,hO)for k=bL+1,bN do bv[k]=cA[k]end;bL=bN;hO=hQ elseif J.type=="name"then hP[J.text]=hK(hO)hO=hO+1;bv[bL]={col=J.col,line=J.line,type="name",text=hP[J.text]}bK=4 else error("invalid local statement")end elseif bK==4 then if J.type=="operator"and J.text==","then bK=3;bv[bL]=J else bK=1;bL=bL-1 end end;bL=bL+1 end;return bv,#P end;return hN end,["token_decode_tree"]=function()return{{":name",{{",",":repeat0"},{"=",{"(",")"}}}},{{{{".",":number"},{":repeat1",":repeat2"}},{{":string","end"},{"local",{":repeat3",":repeat4"}}}},{{{{"if","then"},{{"+","-"},{"0","1"}}},{{{":repeat5",":repeat6"},{"==","["}},{{"]","do"},{"function","return"}}}},{{{{"{","}"},{{"#","*"},{"..","2"}}},{{{":",":repeat7"},{":repeat8","and"}},{{"else","for"},{"nil","or"}}}},{{{{"self","~="},{{"\"\"","/"},{":repeat10",":repeat9"}}},{{{";","<"},{">","elseif"}},{{"false","not"},{"string","true"}}}},{{{{"type",{"%","-1"}},{{"...",":repeat11"},{"<=",">="}}},{{{"error","in"},{"math","os"}},{{"print","sub"},{"table","while"}}}},{{{{{"\"number\"","\"string\""},{"\"table\"",":repeat12"}},{{":repeat13","_"},{"_G","bit32"}}},{{{"break","close"},{"coroutine","find"}},{{"ipairs","match"},{"open","pairs"}}}},{{{{"read","require"},{"setmetatable","tonumber"}},{{"tostring","unpack"},{"write",{"\"function\"","\"nil\""}}}},{{{{"\"r\"","\"w\""},{"^","_ENV"}},{{"__index","debug"},{"getmetatable","gsub"}}},{{{"io","package"},{"pcall","repeat"}},{{"select","until"},{{"\"boolean\"","__newindex"},{"load",{":end","__call"}}}}}}}}}}}}}}end,["token_encode_map"]=function()return{string={code=494,bits=9},["-"]={code=101,bits=7},table={code=1006,bits=10},["*"]={code=229,bits=8},print={code=1004,bits=10},pairs={code=2031,bits=11},ipairs={code=2028,bits=11},getmetatable={code=4086,bits=12},setmetatable={code=2034,bits=11},[";"]={code=488,bits=9},os={code=1003,bits=10},unpack={code=2037,bits=11},select={code=4092,bits=12},tonumber={code=2035,bits=11},[".."]={code=230,bits=8},_={code=2021,bits=11},pcall={code=4090,bits=12},open={code=2030,bits=11},load={code=8190,bits=13},["["]={code=107,bits=7},["%"]={code=994,bits=10},["^"]={code=4082,bits=12},["=="]={code=106,bits=7},[":repeat1"]={code=18,bits=5},[":repeat0"]={code=5,bits=4},[":repeat3"]={code=46,bits=6},require={code=2033,bits=11},[":repeat4"]={code=47,bits=6},[":repeat8"]={code=234,bits=8},[":repeat7"]={code=233,bits=8},["\"table\""]={code=2018,bits=11},["{"]={code=112,bits=7},sub={code=1005,bits=10},["/"]={code=485,bits=9},["..."]={code=996,bits=10},["and"]={code=235,bits=8},type={code=496,bits=9},[":repeat11"]={code=997,bits=10},find={code=2027,bits=11},match={code=2029,bits=11},["or"]={code=239,bits=8},gsub={code=4087,bits=12},["end"]={code=21,bits=5},_G={code=2022,bits=11},math={code=1002,bits=10},["."]={code=16,bits=5},["function"]={code=110,bits=7},tostring={code=2036,bits=11},["}"]={code=113,bits=7},["0"]={code=102,bits=7},["<"]={code=489,bits=9},close={code=2025,bits=11},["\"nil\""]={code=4079,bits=12},read={code=2032,bits=11},[":name"]={code=0,bits=2},["="]={code=6,bits=4},[","]={code=4,bits=4},[">="]={code=999,bits=10},[":repeat2"]={code=19,bits=5},["<="]={code=998,bits=10},["#"]={code=228,bits=8},write={code=2038,bits=11},["~="]={code=241,bits=8},error={code=1000,bits=10},__index={code=4084,bits=12},[":repeat13"]={code=2020,bits=11},coroutine={code=2026,bits=11},[">"]={code=490,bits=9},_ENV={code=4083,bits=12},["\"\""]={code=484,bits=9},[":repeat9"]={code=487,bits=9},["\"r\""]={code=4080,bits=12},["\"w\""]={code=4081,bits=12},__call={code=16383,bits=14},["1"]={code=103,bits=7},debug={code=4085,bits=12},["\"number\""]={code=2016,bits=11},["\"boolean\""]={code=8188,bits=13},["2"]={code=231,bits=8},["\"function\""]={code=4078,bits=12},[":string"]={code=20,bits=5},["-1"]={code=995,bits=10},self={code=240,bits=8},[":number"]={code=17,bits=5},[":repeat5"]={code=104,bits=7},[":end"]={code=16382,bits=14},[":repeat12"]={code=2019,bits=11},["break"]={code=2024,bits=11},["do"]={code=109,bits=7},["else"]={code=236,bits=8},["elseif"]={code=491,bits=9},[":repeat10"]={code=486,bits=9},["false"]={code=492,bits=9},["for"]={code=237,bits=8},bit32={code=2023,bits=11},["\"string\""]={code=2017,bits=11},["if"]={code=48,bits=6},["in"]={code=1001,bits=10},["local"]={code=22,bits=5},["nil"]={code=238,bits=8},["not"]={code=493,bits=9},[")"]={code=15,bits=5},["repeat"]={code=4091,bits=12},["return"]={code=111,bits=7},["then"]={code=49,bits=6},["true"]={code=495,bits=9},["until"]={code=4093,bits=12},["while"]={code=1007,bits=10},["("]={code=14,bits=5},[":repeat6"]={code=105,bits=7},[":"]={code=232,bits=8},["]"]={code=108,bits=7},package={code=4089,bits=12},io={code=4088,bits=12},__newindex={code=8189,bits=13},["+"]={code=100,bits=7}}end}if d[c]then return d[c]else return b(c)end end end;local bW=require"lex"local hN=require"minify"local O=require"compress"local bg=require"decompress"local function hS()print[[Usage: luz [options] <input> [output]
Options:
  -c       Force compression
  -d       Force decompression
  -l <num> Compression level (0-9)
  -m       Minify before compression (experimental)
  -r       Run compressed file
  --help   Show this help
]]end;local hT,fY,aU={}local dq,Q;local aq=false;local hU;for I,hV in ipairs{...}do if hU then if hU==1 then Q=tonumber(hV)end;hU=nil elseif hV:sub(1,2)=="--"then if hV=="--help"then return hS()end elseif hV:sub(1,1)=="-"then for l in hV:sub(2):gmatch(".")do if l=="c"then dq=1 elseif l=="d"then dq=2 elseif l=="l"then hU=1 elseif l=="r"then dq=3 elseif l=="m"then aq=true end end elseif not fY then fY=hV elseif not aU then aU=hV else hT[#hT+1]=hV end end;if not fY then return hS()end;if dq==3 then table.insert(hT,1,aU)aU=nil end;if shell then fY,aU=shell.resolve(fY),aU and shell.resolve(aU)end;local hW=assert(io.open(fY,"rb"))local bh=hW:read("*a")hW:close()if not dq then dq=bh:sub(1,5)=="\27LuzQ"and 2 or 1 end;local hX=pcall(load,"")if dq==3 then local hY=bg(bh)return assert((hX and load or loadstring)(hY,"@"..fY,"t",_ENV))((table.unpack or unpack)(hT))elseif dq==2 then aU=aU or fY..".lua"local hY=bg(bh)hW=assert(io.open(aU,"w"))hW:write(hY)hW:close()else aU=aU or fY..".luz"assert((hX and load or loadstring)(bh))local P=bW(bh,1,2)if aq then P=hN(P)end;local hZ=O(P,Q)hW=assert(io.open(aU,"wb"))hW:write(hZ)hW:close()print(fY..": "..#bh.." => "..#hZ)end
